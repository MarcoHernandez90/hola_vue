<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hola Vue</title>
  <style>
    html, body {
      height: 100vh;
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
    }
    #app, .container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    button {
      margin-top: 24px;
      border: none;
      background-color: white;
      padding: 8px 24px;
      border-radius: 12px;
      cursor: pointer;
    }
    .closed {
      background-color: #eca1a6;
    }
    .opened {
      background-color: #b5e7a0;
    }
    .list {
      display: flex;
      flex-direction: column;
    }
    .item {
      border: 1px solid #444;
      border-radius: 10px;
      padding: 5px;
      margin-top: 5px;
      position: relative;
    }
    .title {
      font-weight: bold;
      font-size: 1.2em;
    }
    .btn-add {
      display: block;
      background-color: #754f92;
      color: #fff;
      margin: auto;
    }
    .post-form {
      padding: 5px;
      background-color: #52b69a;
      border-radius: 5px;
      margin-bottom: 5px;

      > div {
        margin: 3px 0;
      }

      > input, textarea {
        border: 1px solid #aaa;
        border-radius: 3px;
      }
    }
    .btn-delete {
      position: absolute;
      top: 4px;
      right: 10px;
      padding: 1px;
      margin: 0;
      background-color: transparent;
      font-size: 1em;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Enlace de CDN para importar Vue -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

  <!-- Para inicializar una instancia de Vue generalmente se utiliza un
    elemento con el id 'app' -->
  <div id="app">
    <!-- En este elemento podemos agregar información que viene desde Vue con
      las llaves dobles -->
    <!-- {{ text }} -->
  </div>
  <script>
    /* Instanciamos una app de Vue con el método createApp en una constante que
      por nomenclatura se llamará app y después la montaremos con su método
      mount en una constante llamada vm que representa el ViewModel de Vue.
      Este método recibe un objeto llamado Config API con los elementos y las
      funciones a ejecutar en la app y aparte se ejecuta el método mount en el
      elemento 'app' que creamos con HTML */
    const app = Vue.createApp({
      // En este objeto definimos la función data que retornará los la
      // información que utilizaremos en nuestra aplicación
      data() {
        return {
          text: "Accede a tu cuenta",
          // attr: 'src',
          // alt: 'alt',
          // img: 'https://picsum.photos/500/800',
          // counter: 0,
          // firstName: 'Marco',
          // lastName: 'Hernández',
          // now: new Date(),
          // opened: false,
          /* Podemos almacenar estilos dentro de una variable en data manejando el CSS como un objeto, cambiando la nomenclatura de kebab-case a camelCase
          styles: {
            backgroundColor: '#eca1a6'
          } */
          logged: false,
          username: '',
          posts: [{
            'title': 'Título de ejemplo',
            'description': 'Lorem ipsum'
          },{
            'title': 'Título de ejemplo 2',
            'description': 'Lorem ipsum'
          },{
            'title': 'Título de ejemplo 3',
            'description': 'Lorem ipsum'
          }],
          newPost: { 'title': '', 'description': '' },
        };
      },
      /* Vue no puede recibir en sus directivas funciones que nosotros
        declaramos en nuestro código de JavaScript, pero lo que si puede
        hacer es ejecutar métodos que declaramos dentro del atributo methods */
      methods: {
        /* increment() {
          this.counter++;
        },
        decrement() {
          this.counter--;
        }, */
        /* input(e) {
          this.text = e.target.value;
        } */
        /* submit(e) {
          // e.preventDefault();
          this.counter++;
        } */
        /* asdf() {
          console.log('sdafsdfafdf')
        } */
        addPost(newPost) {
          this.posts.push({...newPost});
          newPost.title = '';
          newPost.description = '';
        },
        deletePost(index) {
          this.posts.splice(index, 1);
        },
      },
      /* El atributo computed también guarda métodos, pero la diferencia es que
        los métodos de computed están enfocados a la vista para aplicar
        filtros, formateos o simplemente mostrar la información de las varibles
        de data de una forma diferente que sea más facil tanto de escribir para
        el programador como de leer para el usuario */
      computed: {
        /* fullName() {
          return `${this.firstName} ${this.lastName}`;
        },
        today() {
          return this.now.toLocaleDateString();
        }, */
        /* openDoorText() {
          return !this.opened ? 'Abrir' : 'Cerrar';
        },
        styles() {
          return this.opened ? 'opened' : 'closed';
        }, */
        styles() {
          return this.logged ? 'opened' : 'closed';
        },
        loginText() {
          return !this.logged ? 'Acceder' : 'Salir';
        }
      },
      /* Vue permite agregar observadores que pueden reaccionar a los cambios
        reactivos que tienen las variables en data, esto se puede configurar
        con la propiedad watch. En esta propiedad se deberán crear funciones
        con el nombre de las variables que queremos observar y dos argumentos
        opcionales: el nuevo valor y el anterior.
        IMPORTANTE: No funciona dentro de los templates (como los computed) y
        no retorna valores */
      watch: {
        /* text(newValue, oldValue) {
          console.log('El texto cambió de', oldValue, 'a:', newValue);
          this.asdf();
        }, */
        /* opened(newValue) {
          if ( newValue ) {
            this.text = 'Puerta abierta';
            // this.styles.backgroundColor = '#b5e7a0';
          }
          else {
            this.text = 'Puerta cerrada';
            // this.styles.backgroundColor = '#eca1a6';
          }
        } */
        logged(newValue) {
          if ( newValue ) {
            this.text = 'Cierra sesión';
            // this.styles.backgroundColor = '#b5e7a0';
          }
          else {
            this.text = 'Accede a tu cuenta';
            // this.styles.backgroundColor = '#eca1a6';
          }
        }
      },
      /* También se pueden crear templates para crear los componentes de forma
        declarativa:
        template: `<div>{{ text }}</div>`
        En el caso de los templates se pueden utilizar directivas, que son
        atributos que recibe el HTML de un template generalmente llamadas
        v-<declarativa> a las cuales se les puede asignar un valor de data:
        En este caso podemos utilizar v-text para asignarle el texto que
        contendrá el componente o v-html para cambiar el innerHTML y v-once
        para indicar que se renderizará de forma estática (no reaccionará a
        los cambios en sus atributos o variables que maneje)
        template: `<div v-once v-html="text"></div>`
        También está la directiva v-bind que nos permite transformar los
        atributos nativos de un componente en directivas y poder asignarles
        los valores de variables si es que no queremos agregar las llaves
        dobles. Esto se puede acortar a ':' o incluso se puede utilizar
        v-bind como una directiva que obtiene un JSON con los atributos a
        ligar y su valor
        template: `<img v-bind:src="img" v-bind:alt="img">`
        template: `<img :src="img" :alt="img">`
        template: `<img v-bind:[attr]="img" v-bind:[alt]="img">`
        Además de v-bind para ligar variables reactivas, también se tiene v-on
        que funciona como los event listeners de JavaScript Vanilla pero
        manejando los métodos y variables reactivas de Vue. Este v-on se puede
        acortar con @
        template: `<button v-on:click="increment">{{ counter }}</button>`
        template: `
          <form v-on:submit.prevent="submit">
            <button>{{ counter }}</button>
          </form>`
        template: `
          <button v-on:click="decrement">-</button>&nbsp;
          <span v-text="counter"></span>&nbsp;
          <button v-on:click="increment">+</button>` */
      /* Aparte de todo esto, Vue viene con eventos nativos que nos permiten
        evitarnos código boilerplate como el evento input que nos permite
        ejecutar métodos con cada cambio del elemento en tiempo real  */
      /* template: `
        <p>{{ text }}</p>
        <input type="text" @input="input" :value="text">
      ` */
      /* Este caso se puede acortar aún más con la directiva v-model, la cual
        combina las directivas v-on:input y v-bind:value para que el input,
        textarea o select sean completamente reactivos manejando tanto el
        state como el input del patrón MVVM/Two-way data binding
        template: `
          <p>{{ text }}</p>
          <input type="text" v-model="text">
        ` */
      /* Al momento de mostrar datos al usuario tenemos la opción de utilizar
        métodos de JS o concatenar strings manualmente en el template:
        template: `
          <div>{{ firstName }} {{ lastName }}</div>
          <div>{{ now.toLocaleDateString() }}</div>
        ` */
      /* Pero también se pueden usar métodos computed que están enfocados en
        mostrar de diferente forma la información almacenada (como los filtros
        de los templates en django)
        template: `
          <div>{{ fullName }}</div>
          <div>{{ today }}</div>
        ` */
      /* Además de tener reactividad en los datos, también podemos tener
        reactividad en los estilos, lo cual se consigue creando una variable en
        data que contendrá los estilos en forma de objeto y agregandola a un
        elemento con v-bind:style o manejando clases con v-bind:class en donde
        tendremos la opción de agregar un array de las clases que tendrá o un
        objeto con el nombre de cada una de las clases y un booleano o una
        expresión para indicar si estará activa con true, desactivada con
        false, comparando con una variable o con una expresión, por ejemplo:
        n>1 para true y n<=0 para false, o incluso con un método computado que
        retorne una o más clases
        template: `
          <div class="container" :style="styles">
            <h3>{{ text }}</h3>
            <button @click="opened = !opened">{{ openDoorText }}</button>
          </div>
        `
        template: `
          <div class="container" :class="['opened']">
            <h3>{{ text }}</h3>
            <button @click="opened = !opened">{{ openDoorText }}</button>
          </div>
        `
        template: `
          <div class="container" :class="{ 'opened': opened, 'closed': !opened }">
            <h3>{{ text }}</h3>
            <button @click="opened = !opened">{{ openDoorText }}</button>
          </div>
        `
        template: `
          <div class="container" :class="styles">
            <h3>{{ text }}</h3>
            <button @click="opened = !opened">{{ openDoorText }}</button>
          </div>
        ` */
      /* Vue también soporta control de flujo dentro de su sintáxis
        directamente en los templates, lo cual nos permite tomar decisiones
        o renderizar sólo los elementos necesarios haciendo uso de sus
        directivas. Por ejemplo, se tiene las directivas v-if y v-else para
        crear condicionales y v-for para renderizar elementos con ciclos (a
        estos elementos les podemos asignar el atributo key como un
        identificador)
        template: `
          <div class="container" :class="styles">
            <h3>{{ text }}</h3>
            <div v-if="logged">
              <p>Hola, {{ username }}</p>
              <div class="post-form">
                <div>Título del post:</div>
                <input v-model="newPost.title" type="text">
                <div>Descripción:</div>
                <textarea v-model="newPost.description" name="description" cols="30" rows="4"></textarea>
                <button type="button" class="btn-add" @click="addPost">Agregar post</button>
              </div>
              <div class="list">
                <div v-for="(post, index) in posts" :key="index" class="item">
                  <button type="button" @click="deletePost(index)" class="btn-delete">X</button>
                  <div class="title">{{ post.title }}</div>
                  <p>{{ post.description }}</p>
                </div>
              </div>
            </div>
            <div v-else>
              <div>Username</div>
              <input type="text" v-model="username">
            </div>
            <button @click="logged = !logged">
              <div v-if="!logged">Acceder</div>
              <div v-else>Salir</div>
            </button>
          </div>
        ` */
      /* Para agregar un componente hijo a nuestra app o componente padre,
        lo podemos hacer a través de un tag con el nombre del componente y las
        directivas o props que necesite nuestro componente para funcionar */
      template: `
        <div class="container" :class="styles">
          <h3>{{ text }}</h3>
          <div v-if="logged">
            <p>Hola, {{ username }}</p>
            <PostForm @addPost="newPost => addPost(newPost)" />
            <div class="list">
              <Item v-for="(post, index) in posts" :key="index" :post="post" :index="index" :deletePost="deletePost" />
            </div>
          </div>
          <LoginForm v-else :username="username" v-model:username="username" />
          <LoginButton :logged="logged" @click="logged = !logged" />
        </div>
      `
    });

    /* Para crear componentes dentro de una app de Vue, se puede utilizar el
      método component que recibe como parámetro el nombre del componente y un
      objeto JSON con las opciones de la app (data, methods, template, etc.) y
      una extra llamada props que servirá como una lista de las variables que
      podrá recibir el componente actual desde el componente padre para
      trabajar */
    app.component('Item', {
      props: ["post", "index", "deletePost"],
      template: `
        <div class="item">
          <button type="button" @click="deletePost(index)" class="btn-delete">X</button>
          <div class="title">{{ post.title }}</div>
          <p>{{ post.description }}</p>
        </div>
      `
    });
    app.component('LoginForm', {
      props: ['username'],
      emits: ['update:username'],
      template: `
        <div>Username</div>
        <input type="text" :value="username" @input="$emit('update:username', $event.target.value)">
      `
    });
    app.component('PostForm', {
      data() {
        return {
          newPost: {
            title: '',
            description: ''
          }
        }
      },
      template: `
        <div class="post-form">
          <div>Título del post:</div>
          <input v-model="newPost.title" type="text">
          <div>Descripción:</div>
          <textarea v-model="newPost.description" name="description" cols="30" rows="4"></textarea>
          <button type="button" class="btn-add" @click="$emit('addPost', newPost)">Agregar post</button>
        </div>
      `
    });
    app.component('LoginButton', {
      props: ['logged'],
      template: `
        <button>
          <div v-if="!logged">Acceder</div>
          <div v-else>Salir</div>
        </button>
      `
    });

    const vm = app.mount("#app");
  </script>
</body>
</html>