<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hola Vue</title>
</head>
<body>
  <!-- Enlace de CDN para importar Vue -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

  <!-- Para inicializar una instancia de Vue generalmente se utiliza un
    elemento con el id 'app' -->
  <div id="app">
    <!-- En este elemento podemos agregar información que viene desde Vue con
      las llaves dobles -->
    <!-- {{ text }} -->
    
  </div>
  <script>
    // Instanciamos una app de Vue con el método createApp en una constante que
    // por nomenclatura se llamará vm. Este método recibe un objeto llamado
    // Config API con los elementos y las funciones a ejecutar en la app y
    // aparte se ejecuta el método mount en el elemento 'app' que creamos con
    // HTML
    const vm = Vue.createApp({
      // En este objeto definimos la función data que retornará los la
      // información que utilizaremos en nuestra aplicación
      data() {
        return {
          text: "Hola Vue"
          // attr: 'src',
          // alt: 'alt',
          // img: 'https://picsum.photos/500/800',
          // counter: 0
        };
      },
      /* Vue no puede recibir en sus directivas funciones que nosotros
        declaramos en nuestro código de JavaScript, pero lo que si puede
        hacer es ejecutar métodos que declaramos dentro del atributo methods */
      methods: {
        /* increment() {
          this.counter++;
        },
        decrement() {
          this.counter--;
        }, */
        /* input(e) {
          this.text = e.target.value;
        } */
        /* submit(e) {
          // e.preventDefault();
          this.counter++;
        } */
      },
      /* También se pueden crear templates para crear los componentes de forma
        declarativa:
        template: `<div>{{ text }}</div>`
        En el caso de los templates se pueden utilizar directivas, que son
        atributos que recibe el HTML de un template generalmente llamadas
        v-<declarativa> a las cuales se les puede asignar un valor de data:
        En este caso podemos utilizar v-text para asignarle el texto que
        contendrá el componente o v-html para cambiar el innerHTML y v-once
        para indicar que se renderizará de forma estática (no reaccionará a
        los cambios en sus atributos o variables que maneje)
        template: `<div v-once v-html="text"></div>`
        También está la directiva v-bind que nos permite transformar los
        atributos nativos de un componente en directivas y poder asignarles
        los valores de variables si es que no queremos agregar las llaves
        dobles. Esto se puede acortar a ':' o incluso se puede utilizar
        v-bind como una directiva que obtiene un JSON con los atributos a
        ligar y su valor
        template: `<img v-bind:src="img" v-bind:alt="img">`
        template: `<img :src="img" :alt="img">`
        template: `<img v-bind:[attr]="img" v-bind:[alt]="img">`
        Además de v-bind para ligar variables reactivas, también se tiene v-on
        que funciona como los event listeners de JavaScript Vanilla pero
        manejando los métodos y variables reactivas de Vue. Este v-on se puede
        acortar con @
        template: `<button v-on:click="increment">{{ counter }}</button>`
        template: `
          <form v-on:submit.prevent="submit">
            <button>{{ counter }}</button>
          </form>`
        template: `
          <button v-on:click="decrement">-</button>&nbsp;
          <span v-text="counter"></span>&nbsp;
          <button v-on:click="increment">+</button>` */
        /* Aparte de todo esto, Vue viene con eventos nativos que nos permiten
          evitarnos código boilerplate como el evento input que nos permite
          ejecutar métodos con cada cambio del elemento en tiempo real  */
        /* template: `
          <p>{{ text }}</p>
          <input type="text" @input="input" :value="text">
        ` */
        /* Este caso se puede acortar aún más con la directiva v-model, la cual
          combina las directivas v-on:input y v-bind:value para que el input,
          textarea o select sean completamente reactivos manejando tanto el
          state como el input del patrón MVVM/Two-way data binding */
        template: `
          <p>{{ text }}</p>
          <input type="text" v-model="text">
        `
    }).mount("#app");
  </script>

</body>
</html>