<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hola Vue</title>
</head>
<body>
  <!-- Enlace de CDN para importar Vue -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

  <!-- Para inicializar una instancia de Vue generalmente se utiliza un
    elemento con el id 'app' -->
  <div id="app">
    <!-- En este elemento podemos agregar información que viene desde Vue con
      las llaves dobles -->
    <!-- {{ text }} -->
    
  </div>
  <script>
    // Instanciamos una app de Vue con el método createApp en una constante que
    // por nomenclatura se llamará vm. Este método recibe un objeto llamado
    // Config API con los elementos y las funciones a ejecutar en la app y
    // aparte se ejecuta el método mount en el elemento 'app' que creamos con
    // HTML
    const vm = Vue.createApp({
      // En este objeto definimos la función data que retornará los la
      // información que utilizaremos en nuestra aplicación
      data() {
        return {
          text: "Puerta cerrada",
          // attr: 'src',
          // alt: 'alt',
          // img: 'https://picsum.photos/500/800',
          // counter: 0,
          firstName: 'Marco',
          lastName: 'Hernández',
          now: new Date(),
          opened: false,
        };
      },
      /* Vue no puede recibir en sus directivas funciones que nosotros
        declaramos en nuestro código de JavaScript, pero lo que si puede
        hacer es ejecutar métodos que declaramos dentro del atributo methods */
      methods: {
        /* increment() {
          this.counter++;
        },
        decrement() {
          this.counter--;
        }, */
        /* input(e) {
          this.text = e.target.value;
        } */
        /* submit(e) {
          // e.preventDefault();
          this.counter++;
        } */
        asdf() {
          console.log('sdafsdfafdf')
        }
      },
      /* El atributo computed también guarda métodos, pero la diferencia es que
        los métodos de computed están enfocados a la vista para aplicar
        filtros, formateos o simplemente mostrar la información de las varibles
        de data de una forma diferente que sea más facil tanto de escribir para
        el programador como de leer para el usuario */
      computed: {
        fullName() {
          return `${this.firstName} ${this.lastName}`;
        },
        today() {
          return this.now.toLocaleDateString();
        },
        openDoorText() {
          return !this.opened ? 'Abrir' : 'Cerrar';
        }
      },
      /* Vue permite agregar observadores que pueden reaccionar a los cambios
        reactivos que tienen las variables en data, esto se puede configurar
        con la propiedad watch. En esta propiedad se deberán crear funciones
        con el nombre de las variables que queremos observar y dos argumentos
        opcionales: el nuevo valor y el anterior.
        IMPORTANTE: No funciona dentro de los templates (como los computed) y
        no retorna valores */
      watch: {
        text(newValue, oldValue) {
          console.log('El texto cambió de', oldValue, 'a:', newValue);
          this.asdf();
        },
        opened(newValue) {
          if ( newValue ) { this.text = 'Puerta abierta'; }
          else { this.text = 'Puerta cerrada'; }
        }
      },
      /* También se pueden crear templates para crear los componentes de forma
        declarativa:
        template: `<div>{{ text }}</div>`
        En el caso de los templates se pueden utilizar directivas, que son
        atributos que recibe el HTML de un template generalmente llamadas
        v-<declarativa> a las cuales se les puede asignar un valor de data:
        En este caso podemos utilizar v-text para asignarle el texto que
        contendrá el componente o v-html para cambiar el innerHTML y v-once
        para indicar que se renderizará de forma estática (no reaccionará a
        los cambios en sus atributos o variables que maneje)
        template: `<div v-once v-html="text"></div>`
        También está la directiva v-bind que nos permite transformar los
        atributos nativos de un componente en directivas y poder asignarles
        los valores de variables si es que no queremos agregar las llaves
        dobles. Esto se puede acortar a ':' o incluso se puede utilizar
        v-bind como una directiva que obtiene un JSON con los atributos a
        ligar y su valor
        template: `<img v-bind:src="img" v-bind:alt="img">`
        template: `<img :src="img" :alt="img">`
        template: `<img v-bind:[attr]="img" v-bind:[alt]="img">`
        Además de v-bind para ligar variables reactivas, también se tiene v-on
        que funciona como los event listeners de JavaScript Vanilla pero
        manejando los métodos y variables reactivas de Vue. Este v-on se puede
        acortar con @
        template: `<button v-on:click="increment">{{ counter }}</button>`
        template: `
          <form v-on:submit.prevent="submit">
            <button>{{ counter }}</button>
          </form>`
        template: `
          <button v-on:click="decrement">-</button>&nbsp;
          <span v-text="counter"></span>&nbsp;
          <button v-on:click="increment">+</button>` */
      /* Aparte de todo esto, Vue viene con eventos nativos que nos permiten
        evitarnos código boilerplate como el evento input que nos permite
        ejecutar métodos con cada cambio del elemento en tiempo real  */
      /* template: `
        <p>{{ text }}</p>
        <input type="text" @input="input" :value="text">
      ` */
      /* Este caso se puede acortar aún más con la directiva v-model, la cual
        combina las directivas v-on:input y v-bind:value para que el input,
        textarea o select sean completamente reactivos manejando tanto el
        state como el input del patrón MVVM/Two-way data binding
        template: `
          <p>{{ text }}</p>
          <input type="text" v-model="text">
        ` */
      /* Al momento de mostrar datos al usuario tenemos la opción de utilizar
        métodos de JS o concatenar strings manualmente en el template:
        template: `
          <div>{{ firstName }} {{ lastName }}</div>
          <div>{{ now.toLocaleDateString() }}</div>
        ` */
      /* Pero también se pueden usar métodos computed que están enfocados en
        mostrar de diferente forma la información almacenada (como los filtros
        de los templates en django) */
      template: `
        <div>{{ fullName }}</div>
        <div>{{ today }}</div>
        <div>{{ text }}</div>
        <button @click="opened = !opened">{{ openDoorText }}</button>
      `
    }).mount("#app");
  </script>
</body>
</html>