<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hola Vue</title>
  <style>
    html, body {
      height: 100vh;
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
    }
    #app, .container {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }
    button {
      margin-top: 24px;
      border: none;
      background-color: white;
      padding: 8px 24px;
      border-radius: 12px;
      cursor: pointer;
    }
    .closed {
      background-color: #eca1a6;
    }
    .opened {
      background-color: #b5e7a0;
    }
    .list {
      display: flex;
      flex-direction: column;
    }
    .item {
      border: 1px solid #444;
      border-radius: 10px;
      padding: 5px;
      margin-top: 5px;
      position: relative;
    }
    .title {
      font-weight: bold;
      font-size: 1.2em;
    }
    .btn-add {
      display: block;
      background-color: #754f92;
      color: #fff;
      margin: auto;
    }
    .post-form {
      padding: 5px;
      background-color: #52b69a;
      border-radius: 5px;
      margin-bottom: 5px;

      > div {
        margin: 3px 0;
      }

      > input, textarea {
        border: 1px solid #aaa;
        border-radius: 3px;
      }
    }
    .btn-delete {
      position: absolute;
      top: 4px;
      right: 10px;
      padding: 1px;
      margin: 0;
      background-color: transparent;
      font-size: 1em;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Enlace de CDN para importar Vue -->
  <!-- <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script> -->

  <!-- Para inicializar una instancia de Vue generalmente se utiliza un
    elemento con el id 'app' -->
  <div id="app">
    <!-- En este elemento podemos agregar información que viene desde Vue con
      las llaves dobles -->
    <!-- {{ text }} -->
  </div>
  <script type="module" src="/src/main.js">
    import { createApp, computed } from 'vue';
    /* Instanciamos una app de Vue con el método createApp en una constante que
      por nomenclatura se llamará app y después la montaremos con su método
      mount en una constante llamada vm que representa el ViewModel de Vue.
      Este método recibe un objeto llamado Config API con los elementos y las
      funciones a ejecutar en la app y aparte se ejecuta el método mount en el
      elemento 'app' que creamos con HTML */
    /* const app = Vue.createApp({ */
      // En este objeto definimos la función data que retornará los la
      // información que utilizaremos en nuestra aplicación
      /* data() {
        return {
          text: "Accede a tu cuenta",
          // attr: 'src',
          // alt: 'alt',
          // img: 'https://picsum.photos/500/800',
          // counter: 0,
          // firstName: 'Marco',
          // lastName: 'Hernández',
          // now: new Date(),
          // opened: false,
          Podemos almacenar estilos dentro de una variable en data manejando el CSS como un objeto, cambiando la nomenclatura de kebab-case a camelCase
          styles: {
            backgroundColor: '#eca1a6'
          }
          logged: false,
          username: '',
          posts: [{
            'title': 'Título de ejemplo',
            'description': 'Lorem ipsum'
          },{
            'title': 'Título de ejemplo 2',
            'description': 'Lorem ipsum'
          },{
            'title': 'Título de ejemplo 3',
            'description': 'Lorem ipsum'
          }],
          newPost: { 'title': '', 'description': '' },
        };
      }, */
      /* Vue no puede recibir en sus directivas funciones que nosotros
        declaramos en nuestro código de JavaScript, pero lo que si puede
        hacer es ejecutar métodos que declaramos dentro del atributo methods */
      /* methods: {
        increment() {
          this.counter++;
        },
        decrement() {
          this.counter--;
        },
        input(e) {
          this.text = e.target.value;
        }
        submit(e) {
          // e.preventDefault();
          this.counter++;
        }
        asdf() {
          console.log('sdafsdfafdf')
        }
        addPost(newPost) {
          this.posts.push({...newPost});
          newPost.title = '';
          newPost.description = '';
        },
        deletePost(index) {
          this.posts.splice(index, 1);
        },
      }, */
      /* El atributo computed también guarda métodos, pero la diferencia es que
        los métodos de computed están enfocados a la vista para aplicar
        filtros, formateos o simplemente mostrar la información de las varibles
        de data de una forma diferente que sea más facil tanto de escribir para
        el programador como de leer para el usuario */
      /* computed: {
        fullName() {
          return `${this.firstName} ${this.lastName}`;
        },
        today() {
          return this.now.toLocaleDateString();
        },
        openDoorText() {
          return !this.opened ? 'Abrir' : 'Cerrar';
        },
        styles() {
          return this.opened ? 'opened' : 'closed';
        },
        styles() {
          return this.logged ? 'opened' : 'closed';
        },
        loginText() {
          return !this.logged ? 'Acceder' : 'Salir';
        }
      }, */
      /* Vue permite agregar observadores que pueden reaccionar a los cambios
        reactivos que tienen las variables en data, esto se puede configurar
        con la propiedad watch. En esta propiedad se deberán crear funciones
        con el nombre de las variables que queremos observar y dos argumentos
        opcionales: el nuevo valor y el anterior.
        IMPORTANTE: No funciona dentro de los templates (como los computed) y
        no retorna valores */
      /* watch: {
        /* text(newValue, oldValue) {
          console.log('El texto cambió de', oldValue, 'a:', newValue);
          this.asdf();
        },
        opened(newValue) {
          if ( newValue ) {
            this.text = 'Puerta abierta';
            // this.styles.backgroundColor = '#b5e7a0';
          }
          else {
            this.text = 'Puerta cerrada';
            // this.styles.backgroundColor = '#eca1a6';
          }
        }
        logged(newValue) {
          if ( newValue ) {
            this.text = 'Cierra sesión';
            // this.styles.backgroundColor = '#b5e7a0';
          }
          else {
            this.text = 'Accede a tu cuenta';
            // this.styles.backgroundColor = '#eca1a6';
          }
        }
      }, */
      /* También se pueden crear templates para crear los componentes de forma
        declarativa:
        template: `<div>{{ text }}</div>`
        En el caso de los templates se pueden utilizar directivas, que son
        atributos que recibe el HTML de un template generalmente llamadas
        v-<declarativa> a las cuales se les puede asignar un valor de data:
        En este caso podemos utilizar v-text para asignarle el texto que
        contendrá el componente o v-html para cambiar el innerHTML y v-once
        para indicar que se renderizará de forma estática (no reaccionará a
        los cambios en sus atributos o variables que maneje)
        template: `<div v-once v-html="text"></div>`
        También está la directiva v-bind que nos permite transformar los
        atributos nativos de un componente en directivas y poder asignarles
        los valores de variables si es que no queremos agregar las llaves
        dobles. Esto se puede acortar a ':' o incluso se puede utilizar
        v-bind como una directiva que obtiene un JSON con los atributos a
        ligar y su valor
        template: `<img v-bind:src="img" v-bind:alt="img">`
        template: `<img :src="img" :alt="img">`
        template: `<img v-bind:[attr]="img" v-bind:[alt]="img">`
        Además de v-bind para ligar variables reactivas, también se tiene v-on
        que funciona como los event listeners de JavaScript Vanilla pero
        manejando los métodos y variables reactivas de Vue. Este v-on se puede
        acortar con @
        template: `<button v-on:click="increment">{{ counter }}</button>`
        template: `
          <form v-on:submit.prevent="submit">
            <button>{{ counter }}</button>
          </form>`
        template: `
          <button v-on:click="decrement">-</button>&nbsp;
          <span v-text="counter"></span>&nbsp;
          <button v-on:click="increment">+</button>` */
      /* Aparte de todo esto, Vue viene con eventos nativos que nos permiten
        evitarnos código boilerplate como el evento input que nos permite
        ejecutar métodos con cada cambio del elemento en tiempo real  */
      /* template: `
        <p>{{ text }}</p>
        <input type="text" @input="input" :value="text">
      ` */
      /* Este caso se puede acortar aún más con la directiva v-model, la cual
        combina las directivas v-on:input y v-bind:value para que el input,
        textarea o select sean completamente reactivos manejando tanto el
        state como el input del patrón MVVM/Two-way data binding
        template: `
          <p>{{ text }}</p>
          <input type="text" v-model="text">
        ` */
      /* Al momento de mostrar datos al usuario tenemos la opción de utilizar
        métodos de JS o concatenar strings manualmente en el template:
        template: `
          <div>{{ firstName }} {{ lastName }}</div>
          <div>{{ now.toLocaleDateString() }}</div>
        ` */
      /* Pero también se pueden usar métodos computed que están enfocados en
        mostrar de diferente forma la información almacenada (como los filtros
        de los templates en django)
        template: `
          <div>{{ fullName }}</div>
          <div>{{ today }}</div>
        ` */
      /* Además de tener reactividad en los datos, también podemos tener
        reactividad en los estilos, lo cual se consigue creando una variable en
        data que contendrá los estilos en forma de objeto y agregandola a un
        elemento con v-bind:style o manejando clases con v-bind:class en donde
        tendremos la opción de agregar un array de las clases que tendrá o un
        objeto con el nombre de cada una de las clases y un booleano o una
        expresión para indicar si estará activa con true, desactivada con
        false, comparando con una variable o con una expresión, por ejemplo:
        n>1 para true y n<=0 para false, o incluso con un método computado que
        retorne una o más clases
        template: `
          <div class="container" :style="styles">
            <h3>{{ text }}</h3>
            <button @click="opened = !opened">{{ openDoorText }}</button>
          </div>
        `
        template: `
          <div class="container" :class="['opened']">
            <h3>{{ text }}</h3>
            <button @click="opened = !opened">{{ openDoorText }}</button>
          </div>
        `
        template: `
          <div class="container" :class="{ 'opened': opened, 'closed': !opened }">
            <h3>{{ text }}</h3>
            <button @click="opened = !opened">{{ openDoorText }}</button>
          </div>
        `
        template: `
          <div class="container" :class="styles">
            <h3>{{ text }}</h3>
            <button @click="opened = !opened">{{ openDoorText }}</button>
          </div>
        ` */
      /* Vue también soporta control de flujo dentro de su sintáxis
        directamente en los templates, lo cual nos permite tomar decisiones
        o renderizar sólo los elementos necesarios haciendo uso de sus
        directivas. Por ejemplo, se tiene las directivas v-if y v-else para
        crear condicionales y v-for para renderizar elementos con ciclos (a
        estos elementos les podemos asignar el atributo key como un
        identificador)
        template: `
          <div class="container" :class="styles">
            <h3>{{ text }}</h3>
            <div v-if="logged">
              <p>Hola, {{ username }}</p>
              <div class="post-form">
                <div>Título del post:</div>
                <input v-model="newPost.title" type="text">
                <div>Descripción:</div>
                <textarea v-model="newPost.description" name="description" cols="30" rows="4"></textarea>
                <button type="button" class="btn-add" @click="addPost">Agregar post</button>
              </div>
              <div class="list">
                <div v-for="(post, index) in posts" :key="index" class="item">
                  <button type="button" @click="deletePost(index)" class="btn-delete">X</button>
                  <div class="title">{{ post.title }}</div>
                  <p>{{ post.description }}</p>
                </div>
              </div>
            </div>
            <div v-else>
              <div>Username</div>
              <input type="text" v-model="username">
            </div>
            <button @click="logged = !logged">
              <div v-if="!logged">Acceder</div>
              <div v-else>Salir</div>
            </button>
          </div>
        ` */
      /* Para agregar un componente hijo a nuestra app o componente padre,
        lo podemos hacer a través de un tag con el nombre del componente y las
        directivas o props que necesite nuestro componente para funcionar */
      /* template: `
        <div class="container" :class="styles">
          <h3>{{ text }}</h3>
          <div v-if="logged">
            <p>Hola, {{ username }}</p>
            <PostForm @addPost="newPost => addPost(newPost)" />
            <div class="list">
              <Item v-for="(post, index) in posts" :key="index" :post="post" :index="index" :deletePost="deletePost" />
            </div>
          </div>
          <LoginForm v-else :username="username" v-model:username="username" />
          <LoginButton :logged="logged" @click="logged = !logged" />
        </div>
      ` */
    /* }); */

    /* Para crear componentes dentro de una app de Vue, se puede utilizar el
      método component que recibe como parámetro el nombre del componente y un
      objeto JSON con las opciones de la app (data, methods, template, etc.) y
      una extra llamada props que servirá como una lista de las variables que
      podrá recibir el componente actual desde el componente padre para
      trabajar */
    /* app.component('Item', {
      props: ["post", "index", "deletePost"],
      template: `
        <div class="item">
          <button type="button" @click="deletePost(index)" class="btn-delete">X</button>
          <div class="title">{{ post.title }}</div>
          <p>{{ post.description }}</p>
        </div>
      `
    });
    app.component('LoginForm', {
      props: ['username'],
      emits: ['update:username'],
      template: `
        <div>Username</div>
        <input type="text" :value="username" @input="$emit('update:username', $event.target.value)">
      `
    });
    app.component('PostForm', {
      data() {
        return {
          newPost: {
            title: '',
            description: ''
          }
        }
      },
      template: `
        <div class="post-form">
          <div>Título del post:</div>
          <input v-model="newPost.title" type="text">
          <div>Descripción:</div>
          <textarea v-model="newPost.description" name="description" cols="30" rows="4"></textarea>
          <button type="button" class="btn-add" @click="$emit('addPost', newPost)">Agregar post</button>
        </div>
      `
    });
    app.component('LoginButton', {
      props: ['logged'],
      template: `
        <button>
          <div v-if="!logged">Acceder</div>
          <div v-else>Salir</div>
        </button>
      `
    }); */

    /* Dentro de un template de Vue podemos utilizar tags que esta librería nos
      provee, como por ejemplo el slot, el cual sirve para crear componentes
      "contenedores" que puedan tener un contenido dinámico proporcionado por
      el componente padre dependiendo de en que parte de nuestra aplicación lo
      vayamos a utilizar */
    /* const app = Vue.createApp({
      template: `
        <div>
          <v-header>
            <button>Título</button>
          </v-header>
          <div>Lorem ipsum</div>
        </div>
      `
    });

    app.component("v-header", {
      template: `
        <header>
          <slot></slot>
        </header>
      `
    }); */

    /* Estos slots se pueden usar múltiples veces dentro de un componente
      asignándoles un nombre y utilizando otro tag de Vue llamado template para
      indicar a que slot se le asignará un contenido haciendo uso de la
      directiva v-slot:<nombre del slot> */
    /* const app = Vue.createApp({
      template: `
        <v-layout>
          <template v-slot:header>
            <button>Título</button>
          </template>
          <template v-slot:content>
            Lorem ipsum dolor sit amet.
          </template>
        </v-layout>
      `
    });

    app.component('v-layout', {
      template: `
        <header>
          <slot name="header"></slot>
        </header>
        <div>
          <slot name="content"></slot>
        </div>
      `
    }); */

    /* Al momento de utilizar el atributo props dentro de un componente hijo,
      podemos tratarlo como objeto en lugar de lista para darle opciones o
      atributos a estas propiedades y configurar su comportamiento como, por
      ejemplo, dándole un valor por default */
    /* const app = Vue.createApp({
      data() {
        return {
          items: ['uno', 'dos', 'tres']
        }
      },
      methods: {
        removeItem(index) {
          this.items.splice(index, 1);
        }
      },
      template: `
        <ul>
          <v-item v-for="(item, index) in items" v-bind:text="item" @click="removeItem(index)" />
        </ul>
      `
    });

    app.component('v-item', {
      props: {
        text: {
          type: String,
          // default: "Texto"
        }
      },
      template: `
        <li>{{ text }}</li>
      `
    }); */

    /* Esto es para comunicar al componente padre con el hijo, pero si se
      quiere comunicar al hijo con el padre, se deben utilizar otros métodos
      para no interferir en las operaciones y el manejo de datos de el
      componente padre. Una forma es utilizando los emit, que son emisores de
      eventos que el componente padre observa y reacciona a su manera a estos
      eventos */
    /* const app = Vue.createApp({
      data() {
        return {
          items: ['uno', 'dos', 'tres']
        }
      },
      methods: {
        removeItem(index) {
          this.items.splice(index, 1);
        }
      },
      template: `
        <ul>
          <v-item v-for="(item, index) in items" v-bind:text="item" v-on:remove="removeItem(index)" />
        </ul>
      `
    });

    app.component('v-item', {
      props: {
        text: String
      },
      methods: {
        remove() {
          // Emitimos el evento remove
          this.$emit('remove');
        }
      },
      template: `<li v-on:click="remove">{{ text }}</li>`
    }); */

    /* Para utilizar la directiva v-model con los componentes se debe hacer uso
      de los emit para emitir el evento update:<variable> en el evento input
      del componente hijo */
    /* const app = Vue.createApp({
      data() {
        return {
          text: "Hola Vue"
        };
      },
      template: `
        <div>
          <p>{{ text }}</p>
          <v-input v-model:value="text" />
        </div>
      `
    });

    app.component('v-input', {
      props: {
        inputValue: String
      },
      methods: {
        updateValue(event) {
          this.$emit("update:value", event.target.value);
        }
      },
      template: `
        <input type="text" v-bind:value="inputValue" v-on:input="updateValue" />
      `
    }); */

    /* Además de componentes padre e hijo, se tienen componentes profundos
      (componentes 'nieto' y 'abuelo', por así decir) los cuales no pueden
      comunicarse directamente con los métodos utilizados anteriormente. Para
      comunicarse se deben utilizar los atributos provide en el componente raíz
      para proveer información a los demás componentes e inject en el
      componente profundo para leer esa información. Para darle reactividad a
      esta información, se debe definir provide como una función y el valor de
      las variables a proveer con el método computed de la clase Vue. */

    const app = createApp({
      data() {
        return {
          text: 'Hola Vue'
        };
      },
      provide() {
        return {
          otroTexto: computed(() => this.text)
        };
      },
      template: `
        <div>{{ text }}</div>
        <segundo />
      `
    });

    app.component('segundo', {
      template: `
        <tercero />
      `
    });

    app.component('tercero', {
      inject: {
        otroTexto: {
          from: "otroTexto"
        }
      },
      template: `<div>{{ otroTexto }}</div>`
    });

    const vm = app.mount("#app");

    /* Las apps de Vue simplemente son objetos creados con esta librería y, en
      cualquier momento, podemos acceder a sus propiedades y métodos desde JS
      como con cualquier otro objeto que creemos. Esto se puede lograr con una
      lista de atributos que nos da Vue para un mejor manejo de las instancias
      de los componentes. Por ejemplo, con $root podemos acceder al componente raíz */
    console.log(vm.$root);

  </script>
  <script type="module" src="/src/Hola.vue"></script>
  
</body>
</html>